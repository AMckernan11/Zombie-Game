import javafx.event.ActionEvent;
import javafx.scene.*;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import java.util.*;

//Based on Existing player class on Git
//Automated Sections can be dropped into any other class... or an Updated Player Class
//Perhaps we should have a Token or Actor class which the Player and similar classes Extend/inplement
//Aidan Mckernan

//Things Class should do:
/*
    Pathfind to Point DONE
        add Mouse Event support to Register Input, plug in Pathfinder DONE
        Prevent Teleportation DONE
    Allow Player Control DONE
    Pathfind to Target
        Target Selection
    Die DONE
    Do Something to Target

    Finding and doing something to targets
 */

public class FriendlyAI {
    private Scene currentScene;
    public int x, y = 0;
    private int offset = 5;
    private Map map;
    private Rectangle rect = new Rectangle(MapTile.tileSize - offset, MapTile.tileSize - offset);
    private Pane pane;
    private Queue actionList;
    private Image rect1 = new Image("Desktop/ZombieRight",MapTile.tileSize - offset, MapTile.tileSize - offset,true,true);//Fix location of URL to somewhere that goes with the Java
    private Image rect2 = new Image("Desktop/ZombieLeft",MapTile.tileSize - offset, MapTile.tileSize - offset,true,true);
    private Image rect3 = new Image("Desktop/ZombieBottom",MapTile.tileSize - offset, MapTile.tileSize - offset,true,true);
    private Image rect4 = new Image("Desktop/ZombieTop",MapTile.tileSize - offset, MapTile.tileSize - offset,true,true);
    private Image CurrentRect = rect1;

    public FriendlyAI(Pane pane, Map map){
        this.map = map;
        this.pane = pane;
        createFriendlyAI();
    }

    public FriendlyAI(Pane pane, Map map, int x, int y){
        this.x = x;
        this.y = y;
        this.map = map;
        this.pane = pane;
        createFriendlyAI();
    }
    public void createFriendlyAI(){
        pane.getChildren().add(rect);
        rect.setFill(Color.LIGHTGRAY);
        rect.setStroke(Color.WHITE);
        rect.setTranslateX(x * MapTile.tileSize + (offset+1) / 2);
        rect.setTranslateY(y * MapTile.tileSize + (offset+1) / 2);
        //movePlayer();
    }

    //Method determines a simple Rectangular path to a Point from Current position
    //Does not account for Obstacles in Path
    //Returns Queue of Movements
    //Possible Future Actions: Implement A* Pathfinding Program; Waypoints
    //Seperate method for Future Proofing
    private Queue pathfinder(int endX, int endY){
        Queue movements = new LinkedList();
        if(endX > x){
            for(int i = x; x <= endX; i++){
                movements.add(1);//Right
            }
        }else{
            for(int i = endX; endX <= x; i++){
                movements.add(2);//Left
            }
        }

        if(endY > y){
            for(int i = y; i >= endY; i++){
                movements.add(3);//Down
            }
        }else{
            for(int i = endY; i >= y; i++){
                movements.add(4);//Up
            }
        }//Simplistic

        return movements;
    }

    public void autoMove(int action){

        if(action == 1){
            x = x + 1;
        }else if(action == 2){
            x = x - 1;
        }else if(action == 3){
            y = y + 1;
        }else{
            y = y - 1;
        }

        //System.out.println("Key Pressed: " + ke.getCode());
        System.out.println("FriendlyAI is @: [" + x + ", " + y + "]");
        rect.setTranslateX(x * MapTile.tileSize + (offset + 1) / 2);
        rect.setTranslateY(y * MapTile.tileSize + (offset + 1) / 2);

    }


    //Currently a Chunk of Pusedocode with some actual Java leading off of here
    public void friendlyAIActions(int XTarget, int YTarget){




        if(XTarget > -1){



            //Ideally this method creates a path from the current location to the target
            //I need to figure out how to return a target X/Y value from the map to the Actor

            while(!actionList.isEmpty()){
                actionList.remove();
            }

            actionList = pathfinder(XTarget,YTarget);//Dummy Values, Intentionally Overbuilt for possible Future Path Finding

            //iterate over queue doing actions
            //Direct Control or Point to Point
            //Direct Control is Easy, Point to Point must be done.
            //call registerInput(KeyEvent ke)
        }else if(XTarget == -1){//Runs when actor in active focus and target not given
            //do registerInput
        }else{
            //Find XY Co ords of Closest Target Actor
            //Feed Co ords into Pathfinder
            //Execute
            //If Plan Issued Interrupt to Execute Plan

            Queue actions = pathfinder(1,2);//Dummy Values, Intentionally Overbuilt for possible Future Path Finding
            System.out.println("AI has selected target at X Y");
            while(!actions.isEmpty()) {
                autoMove(actions.remove());//Intentionally Overbuilt for possible Future Path Finding
                if(false){
                    //Escape Loop, Execute New Plan. If it's clicked on it should do something new
                }
            }
            System.out.println("AI has reached Objective");
        }

    }

    //Idealy this method runs when the Actor has been selected and another space has not, such that the Zombie acts like a second player, when in focus
    public void registerInput(KeyEvent ke, MouseEvent me1, MouseEvent me2, boolean mouseevent1, boolean mouseevent2) {
        if(actionList.isEmpty()) {
            if (ke.getCode() == KeyCode.W) {
                if (y != 0) {
                    y--;
                }
            }
            if (ke.getCode() == KeyCode.A) {
                if (x != 0) {
                    x--;
                }
            }
            if (ke.getCode() == KeyCode.S) {
                if (y != map.getSize_y() - 1) {
                    y++;
                }
            }
            if (ke.getCode() == KeyCode.D) {
                if (x != map.getSize_x() - 1) {
                    x++;
                }
            }

            System.out.println("Key Pressed: " + ke.getCode());
            System.out.println("FriendlyAI is @: [" + x + ", " + y + "]");
            rect.setTranslateX(x * MapTile.tileSize + (offset + 1) / 2);
            rect.setTranslateY(y * MapTile.tileSize + (offset + 1) / 2);

            if (mouseevent1) {

                if ((int) me1.getX / MapTile.tileSize == x && (int) me1.getY / MapTile.tileSize == y) {

                    if (mouseevent2) {
                        friendlyAIActions(me2.getX / Maptile.tileSize, me2.getY / MapTile.tileSize)
                    } else {
                        friendlyAIActions(-1, -1);
                    }

                }

            }
        }else{
            autoMove(actionList.remove());
            if(actionList.isEmpty()){
                System.out.println("AI has reached Objective at "+x+", "+y);
            }
        }
    }

    public void killed(){
        while(!actionList.isEmpty()){
            actionList.remove();
        }
        x = -1;
        y = -1;
        rect.setTranslateX(x * MapTile.tileSize + (offset + 1) / 2);
        rect.setTranslateY(y * MapTile.tileSize + (offset + 1) / 2);

    }
}
/*
Sprite Plan:
the sprites live off screen at -1/-1
when the last location is correct for a different sprite the sprite moves to the correct position and the old sprite goes to -1,-1
Sprite currently in use is tracked as "CurrectRect"
 */
